{
    "componentChunkName": "component---src-pages-objectscripts-objectlaunch-mdx",
    "path": "/objectscripts/objectlaunch/",
    "result": {"pageContext":{"frontmatter":{"title":"Object Launchpoint"},"relativePagePath":"/objectscripts/objectlaunch.mdx","titleType":"append","MdxNode":{"id":"2e183f3c-1fe4-5af6-aa84-9c97d76d7a47","children":[],"parent":"967acc16-84ac-5434-b140-3fe8b6313847","internal":{"content":"---\ntitle: Object Launchpoint\n---\n\n## Object Launchpoint\nThis launchpoint lets you invoke scripts for the Mbo events – init and save point ones [add, update and delete]. \nIn addition to those events, this launch point also taps into the pre-add [`can add`] and pre-delete [`can delete`] events which can control whether a mbo can be added or deleted. \nA launch point can be configured to listen to one or more of these events at the\nsame time. The script will have access to the event Mbo [via the implicit variable\n`mbo`], the MboSet as well as all the related Mbos.\nTo design scripts using Object Launchpoint launch the “Create Scripts with Object Launch Point” wizard as shown below.\n\n![Object Launchpoint UI](olpui.jpg)\n\n### Init Event\nThe initialization event based scripts can\nbe used to set calculated fields, set fields as readonly/required/hidden or set\nconditional defaults to mbo attributes. The save point event based scripts can be\nused to implement save point object validations as well as save point actions.\nBelow is an example that will demonstrate a initialization point script and the next\none would demonstrate a save point script.\nSo lets take the use case in mind before we jump into the code and\nconfiguration. Suppose we want to customize the Asset application to display the\ntotal spare part quantity in a new non-persistent Asset object attribute called\nsparepartqty. This boils down to the requirement - whenever an Asset mbo gets\ninitialized the sparepartqty will display the sum of all the spare part quantities\nassociated with that asset. So based on our knowledge of launch points we get\nthat it will be a Object Launch Point for the object Asset and we need to attach\nthe script to the initialization event of the Asset object. \nTo do this we need to launch the “Create Scripts with Object Launch Point” wizard as shown before.\nOnce the wizard is launched the first thing we do is to create a launch point as\nshown below. Note that the “initialize” event is what we want to use for launching\nthis script\n\n![Object Init Event](olpuipage1.jpg)\n\nSo now lets look at the variables we might need to do this customization. First of\ncourse is a variable called sptqt which binds to the new Asset mbo attribute\nsparepartqty. Now we only intend to set the value of this attribute and hence this\nvariable would be of type OUT. Next we need to get all the quantities from the\nrelated Sparepart Mbos of the Asset. To do that we use the array variable\nnotation `*` to get an array of quantity values from the related sparepart MboSet.\nLets say the array variable is qtys and its bind value would be `<asset to\nsparepart relation name>.<attribute name>*` which is `sparepart.quantity*`. The `*`\nat the end of-course indicates the array nature of this variable and also instructs\nthe framework to form the array using the specified relationship.\n\n![Object Init Event](olpuipage2.jpg)\n\nAnd as mentioned earlier array variables are always of type IN and that is perfect\nfor this as we are not modifying the quantities – we are merely summing that up.\nSo with these basic variables defined we next would attempt to write the script as\nbelow\n\n```python\nif qtys is not None:\n  sptqt = sum(qtys)\n```\n\nBasically a 2 liner which validates if there are infact sparepart Mbo's and if there\nis then sum them up and set it to the sptqt variable. The scripting framework\npicks that up and sets the value back to the binding of the sptqt ie sparepartqty.\nSo the amount of Java coding done here is a BIG ZERO – its a pure jyhton\nscript. Now going by the nature of the calculated fields – the sparepartqty should\nbe always read only. And what best place to set that to read only other than this\nscript – which embodies the Asset initialization event. Below is the final script\nwhich adds the code to set the sparepartqty attribute to read only.\n\n```python\nsptqt_readonly=True\nif qtys is not None:\n  sptqt = sum(qtys)\n```\nOnce you press the create button in the last wizard step to create the script – a\nsuccessful creation of the script and the launch point will generate this response\nas shown below:\n\n![Launch point create confirmation](lpcreate.jpg)\n\nIn case of a compilation error you would be forced to stay back on the last page\ntill you cancell or fix this script.\n\nHere you see the magic of this implicit variable concept. When you bound sptqt\nto sparepartqty attribute the scripting framework injected at runtime not only the\nvariable sptqt but also some implicit variables like sptqt_readonly, sptqt_required\nand sptqt_hidden each of which are of type boolean and caters to the read only,\nrequired and hidden flags of the Mbo attribute.\n\nAnother way to do the same is by leveraging the mbo apis:\n\n```python\nfrom psdi.mbo import MboConstants\nmbo.setValue(\"sparepartqty\",mbo.getMboSet(\"SPAREPART\").sum(\"quantity\"))\nmbo.setFieldFlag(\"sparepartqty\",MboConstants.READONLY, true)\n```\n\n\n### App Validate Event\n\n\nLeverage this Object launch point to do the validation routines for the full object. Compared to the Attribute launch point \"validate\" event, \nwhich is geared towards individual attribute validations, this point offers the full Mbo to validate. The implicit variables available at this script point are identical\nto the ones available for the save event - \"before save\" script point. It is recommended to leverage this point for validation compared to the \"before save\" script point.\nOften times application/framework code will call the Mbo validate routine. In such cases this script point is going to get invoked and the \"before save\" will not be invoked. \nSo while the before save is good to handle save point actions, validation should ideally be handled in this script point.\n\n\n### Save Event\nNext lets move onto some save point validations which hopefully will help\ndemonstrate more features of this framework.   \n\n\n#### On Add\nAs before lets deal with the use case first. The use case here is a need to customize the Asset mbo to enforce a\nnaming convention for assets [assetnum] based on their types [assettype]. This\neffectively boils down to the requirement that **whenever we are creating Assets**\nwe have to follow a naming convention for the assetnum. The key words here\nare in blocks which help us identify the launchpoint type and the event point in\nthat type. Its an object launchpoint for the Asset mbos add event. So we use the\nObject Launch point wizard to create and deploy this custom logic. To start with\nwe need to figure out the variables and their bindings. From the requirement its\nclear we need the 2 input values from the assetnum and assettype. So there are\n2 IN variables called anum and atype which are bound to those attributes\nrespectively. Those are the only 2 variables that we need to do this task. Below\nis the script code [in Jython]\n\n```python\nif atype_internal=='FACILITIES' and not anum.startswith('FT'):\n  service.error('asset','invalidassetprefix',['FT'])\nelif atype_internal=='FLEET' and not anum.startswith('FL'):\n  service.error('asset','invalidassetprefix',['FL'])\nelif atype_internal=='IT' and not anum.startswith('IT'):\n  service.error('asset','invalidassetprefix',['IT'])\nelif atype_internal=='PRODUCTION' and not anum.startswith('PR'):\n  service.error('asset','invalidassetprefix',['PR'])\n```\n\nNote that this same could be acheieved without defining those variables and just using the implicit variable `mbo` and leveraging the maximo SDK for internal values as shown below\n\n```python\nfrom psdi.server import MXServer\natypeinternal = MXServer.getMXServer().getMaximoDD().getTranslator().toInternalString('ASSETTYPE', mbo.getString('assettype'));\nanum=mbo.getString('assetnum')\n```\nAlso note that scripting framework used to support another way to throw errors by setting the implicit variables `errorkey`,`errorgroup` and `params`. This way has been deprecated as it was not real time ie ie when the script code is executing the exception would be thrown only\nafter the script code has completed execution. At the end of the script execution the framework would detect that an error flag is set and it will throw the\ncorresponding Maximo excpetion for that error group/key combination. So you should consider the fact that even after setting the error flags in the script – the\nscript execution will continue and unless you have adequate checks in your script code to bypass that code if the error flag is set. \nWe recommend not using that approach anymore and instead use the real time error approach as shown in the previous example.  \n\n\nAnother way to throw error would have been to use the MXException api directly as shown below:\n\n```python\nfrom psdi.util import MXApplicationException\n\nif <some condition>:\n  params = [prefix,assettype]\n  raise MXApplicationException('asset','invalidassetprefix', params)\n```\n\nAs before the scripting framework takes care of all the plumbing behind the scenes. Once you are done submitting your script using the wizard you can\ncome to the Asset app and try to save a test asset. You should see your validation routine gets executed immediately. No restart, No rebuilding ear and No redeployment.\n\n#### On Update\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for mbo updates. \n\n#### On Delete\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for mbo updates. \nNote that this should be leveraged to customize business logic when a mbo delete happens and not to prevent or allow a mbo delete. We should leverage the \"can delete\" event for that.\n\n#### Before Save, After Save and After Commit Event in Object Launch Point\n75 Scripting supported only the “Before Save” events in the Object Launchpoint. Although that is\nthe most common place where we do customizations, we often see the need to attach some\ncustomizations at the after save and after commit events - mostly when we are doing some\nactions that need to be done after the Mbo has been saved or committed. After save is the\nphase when the Mbo’s sql statement (insert/update/delete) has been fired, but the commit has\nnot happened. After commit stage happens when the Mbo in the transaction has been\ncommitted ie the database commit has been successfully executed.\nAfter save is events are good for writing to an external storage. For example - Maximo\nIntegration Events are processed at the after save event. In this phase if the write fails, we can\nalways roll back the Mbo transaction. Also at this stage - all Mbo validations have passed and hence the chances of failure due to Maximo business logic failure is very low.\n\n\nAfter commit events are good for actions that require your Maximo data to be commited. For\nexample you may want to send an SMS only when an Asset has been reported “BROKEN”.\nYou can access the \"mbo\" variable at all of the script points here.\n\n### Can Add Event\nWe can control whether we can add a Mbo using scripting Object Launchpoint \"Allow Object Creation\".\nThis is an Object Launch Point - \"Allow Object Creation\" where you can control whether you can\nadd a new Mbo, given the current state of the system. This point pairs up with the canAdd callback that we have in the MboSet\nframework.\n\n\nLets take a use case where we want to validate that a POLINE can be added to a PO only when\nthe PO has the vendor information set.\nThe script code to do that is shown below:\n\n```python\nif mboset.getOwner() is not None and mboset.getOwner().getName()==\"PO\" and mboset.getOwner().isNull(\"vendor\"):\n  service.error(\"po\",\"novendor_noline\")\n```\nNote that here, there is no implicit variable called \"mbo\" as the launch point is invoked before\nthe Mbo is created. At that point all you have is the MboSet (implicit variable \"mboset\") for the POLINE.\nIf you are wondering why this cannot be done using the init Object launch point, the answer is\nthat its little too late. At that point the Mbo has already been created and added to the set. Rejecting it at the point would have not helped.\nAlso note the usage of the global \"service\" variable here to throw the error in real time. This effectively replaces setting the errorgrp and\nerrorkey variables to throw error.\n\n### Can Delete Event\nSimilar to the \"Can Add\", this Object Launch Point helps validate whether a Mbo can be deleted\nor not. Going with the POLINE object, say we want to enforce a validation that the line should\nnot be deleted, if the PO is of priority 1.\n\n```python\nif mbo.getOwner() is not None and mbo.getOwner().getName()==\"PO\" and !mbo.getOwner().isNull(\"priority\") and and mbo.getOwner().getInt(\"priority\")==1:\n  service.error(\"po\",\"nolinedelete_forpriority1\")\n```\nNote that in this case, the mbo is already there (which we are trying to validate for deletion) and\nhence we can leverage implicit variable mbo to do the validation.\n\n\n### Adding validation to the virtual (aka Nonpersistent) mbos (on execute)\n\nIn this sample we are going use the change status dialog from the Asset Application to validate\nif the memo is filled in when the Asset status is set to BROKEN.  \n\n\nWe will write a Object launch point script – MEMOREQD, which will validate on OK button press\nof the dialog that memo is required for status BROKEN. The event will be “save/add”. This will\nmap to the “execute” call back for Nonpersistent mbos. The object name would be\nASCHANGESTATUS. We used Python for this sample.  \n\n\n```python\nif mboset.getMbo(0).getString(\"status\")==\"BROKEN\" and mboset.getMbo(0).isNull(\"pluscmemo\"):\n  service.error(\"memo\",\"reqd\")\n```\n\nNote the use of the `mboset` variable, which is leveraged to get the current Mbo at 0 index. Now\ntry the change status dialog to see if it throws the memo#reqd error when you do not specify the\n\"memo\" for BROKEN.\n\n\n### Adding setup logic for virtual (aka Nonpersistent) mbos (on setup)\n\nNonpersistent mbosets will get a callback from the Maximo framework for loading the mbos from whatever data \nsource the application programmer planned on using to load the data for this mboset. We have a script point to handle this very use case.\nThe Object \"init\" launch point event for non-persistent objects would provide 2 callbacks. The first callback would be for this \"setup\" event. \nThe script developer can check for the `onsetup` implicit variable (boolean). For setup events, this variable will be set to true. The script can then use the \n`mboset` variable to fill it up with mbos. Note that this script point executes after the mbosets default setup has been called. There is not script point for a \"before setup\" event.\n\n```python\nif onsetup:\n  mbo = mboset.add()\n  mbo.setValue(\"attr1\",\"value1\")\n  mbo.setValue(\"attr2\",\"value2\")\n```\n\nThe above example shows how the \"setup\" event is leveraged to set up the non-persistent mbo. One can use a loop to setup the set with multiple mbo records too.\n\n","type":"Mdx","contentDigest":"086a63d813944d80fdb4542e5df5d624","owner":"gatsby-plugin-mdx","counter":167},"frontmatter":{"title":"Object Launchpoint"},"exports":{},"rawBody":"---\ntitle: Object Launchpoint\n---\n\n## Object Launchpoint\nThis launchpoint lets you invoke scripts for the Mbo events – init and save point ones [add, update and delete]. \nIn addition to those events, this launch point also taps into the pre-add [`can add`] and pre-delete [`can delete`] events which can control whether a mbo can be added or deleted. \nA launch point can be configured to listen to one or more of these events at the\nsame time. The script will have access to the event Mbo [via the implicit variable\n`mbo`], the MboSet as well as all the related Mbos.\nTo design scripts using Object Launchpoint launch the “Create Scripts with Object Launch Point” wizard as shown below.\n\n![Object Launchpoint UI](olpui.jpg)\n\n### Init Event\nThe initialization event based scripts can\nbe used to set calculated fields, set fields as readonly/required/hidden or set\nconditional defaults to mbo attributes. The save point event based scripts can be\nused to implement save point object validations as well as save point actions.\nBelow is an example that will demonstrate a initialization point script and the next\none would demonstrate a save point script.\nSo lets take the use case in mind before we jump into the code and\nconfiguration. Suppose we want to customize the Asset application to display the\ntotal spare part quantity in a new non-persistent Asset object attribute called\nsparepartqty. This boils down to the requirement - whenever an Asset mbo gets\ninitialized the sparepartqty will display the sum of all the spare part quantities\nassociated with that asset. So based on our knowledge of launch points we get\nthat it will be a Object Launch Point for the object Asset and we need to attach\nthe script to the initialization event of the Asset object. \nTo do this we need to launch the “Create Scripts with Object Launch Point” wizard as shown before.\nOnce the wizard is launched the first thing we do is to create a launch point as\nshown below. Note that the “initialize” event is what we want to use for launching\nthis script\n\n![Object Init Event](olpuipage1.jpg)\n\nSo now lets look at the variables we might need to do this customization. First of\ncourse is a variable called sptqt which binds to the new Asset mbo attribute\nsparepartqty. Now we only intend to set the value of this attribute and hence this\nvariable would be of type OUT. Next we need to get all the quantities from the\nrelated Sparepart Mbos of the Asset. To do that we use the array variable\nnotation `*` to get an array of quantity values from the related sparepart MboSet.\nLets say the array variable is qtys and its bind value would be `<asset to\nsparepart relation name>.<attribute name>*` which is `sparepart.quantity*`. The `*`\nat the end of-course indicates the array nature of this variable and also instructs\nthe framework to form the array using the specified relationship.\n\n![Object Init Event](olpuipage2.jpg)\n\nAnd as mentioned earlier array variables are always of type IN and that is perfect\nfor this as we are not modifying the quantities – we are merely summing that up.\nSo with these basic variables defined we next would attempt to write the script as\nbelow\n\n```python\nif qtys is not None:\n  sptqt = sum(qtys)\n```\n\nBasically a 2 liner which validates if there are infact sparepart Mbo's and if there\nis then sum them up and set it to the sptqt variable. The scripting framework\npicks that up and sets the value back to the binding of the sptqt ie sparepartqty.\nSo the amount of Java coding done here is a BIG ZERO – its a pure jyhton\nscript. Now going by the nature of the calculated fields – the sparepartqty should\nbe always read only. And what best place to set that to read only other than this\nscript – which embodies the Asset initialization event. Below is the final script\nwhich adds the code to set the sparepartqty attribute to read only.\n\n```python\nsptqt_readonly=True\nif qtys is not None:\n  sptqt = sum(qtys)\n```\nOnce you press the create button in the last wizard step to create the script – a\nsuccessful creation of the script and the launch point will generate this response\nas shown below:\n\n![Launch point create confirmation](lpcreate.jpg)\n\nIn case of a compilation error you would be forced to stay back on the last page\ntill you cancell or fix this script.\n\nHere you see the magic of this implicit variable concept. When you bound sptqt\nto sparepartqty attribute the scripting framework injected at runtime not only the\nvariable sptqt but also some implicit variables like sptqt_readonly, sptqt_required\nand sptqt_hidden each of which are of type boolean and caters to the read only,\nrequired and hidden flags of the Mbo attribute.\n\nAnother way to do the same is by leveraging the mbo apis:\n\n```python\nfrom psdi.mbo import MboConstants\nmbo.setValue(\"sparepartqty\",mbo.getMboSet(\"SPAREPART\").sum(\"quantity\"))\nmbo.setFieldFlag(\"sparepartqty\",MboConstants.READONLY, true)\n```\n\n\n### App Validate Event\n\n\nLeverage this Object launch point to do the validation routines for the full object. Compared to the Attribute launch point \"validate\" event, \nwhich is geared towards individual attribute validations, this point offers the full Mbo to validate. The implicit variables available at this script point are identical\nto the ones available for the save event - \"before save\" script point. It is recommended to leverage this point for validation compared to the \"before save\" script point.\nOften times application/framework code will call the Mbo validate routine. In such cases this script point is going to get invoked and the \"before save\" will not be invoked. \nSo while the before save is good to handle save point actions, validation should ideally be handled in this script point.\n\n\n### Save Event\nNext lets move onto some save point validations which hopefully will help\ndemonstrate more features of this framework.   \n\n\n#### On Add\nAs before lets deal with the use case first. The use case here is a need to customize the Asset mbo to enforce a\nnaming convention for assets [assetnum] based on their types [assettype]. This\neffectively boils down to the requirement that **whenever we are creating Assets**\nwe have to follow a naming convention for the assetnum. The key words here\nare in blocks which help us identify the launchpoint type and the event point in\nthat type. Its an object launchpoint for the Asset mbos add event. So we use the\nObject Launch point wizard to create and deploy this custom logic. To start with\nwe need to figure out the variables and their bindings. From the requirement its\nclear we need the 2 input values from the assetnum and assettype. So there are\n2 IN variables called anum and atype which are bound to those attributes\nrespectively. Those are the only 2 variables that we need to do this task. Below\nis the script code [in Jython]\n\n```python\nif atype_internal=='FACILITIES' and not anum.startswith('FT'):\n  service.error('asset','invalidassetprefix',['FT'])\nelif atype_internal=='FLEET' and not anum.startswith('FL'):\n  service.error('asset','invalidassetprefix',['FL'])\nelif atype_internal=='IT' and not anum.startswith('IT'):\n  service.error('asset','invalidassetprefix',['IT'])\nelif atype_internal=='PRODUCTION' and not anum.startswith('PR'):\n  service.error('asset','invalidassetprefix',['PR'])\n```\n\nNote that this same could be acheieved without defining those variables and just using the implicit variable `mbo` and leveraging the maximo SDK for internal values as shown below\n\n```python\nfrom psdi.server import MXServer\natypeinternal = MXServer.getMXServer().getMaximoDD().getTranslator().toInternalString('ASSETTYPE', mbo.getString('assettype'));\nanum=mbo.getString('assetnum')\n```\nAlso note that scripting framework used to support another way to throw errors by setting the implicit variables `errorkey`,`errorgroup` and `params`. This way has been deprecated as it was not real time ie ie when the script code is executing the exception would be thrown only\nafter the script code has completed execution. At the end of the script execution the framework would detect that an error flag is set and it will throw the\ncorresponding Maximo excpetion for that error group/key combination. So you should consider the fact that even after setting the error flags in the script – the\nscript execution will continue and unless you have adequate checks in your script code to bypass that code if the error flag is set. \nWe recommend not using that approach anymore and instead use the real time error approach as shown in the previous example.  \n\n\nAnother way to throw error would have been to use the MXException api directly as shown below:\n\n```python\nfrom psdi.util import MXApplicationException\n\nif <some condition>:\n  params = [prefix,assettype]\n  raise MXApplicationException('asset','invalidassetprefix', params)\n```\n\nAs before the scripting framework takes care of all the plumbing behind the scenes. Once you are done submitting your script using the wizard you can\ncome to the Asset app and try to save a test asset. You should see your validation routine gets executed immediately. No restart, No rebuilding ear and No redeployment.\n\n#### On Update\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for mbo updates. \n\n#### On Delete\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for mbo updates. \nNote that this should be leveraged to customize business logic when a mbo delete happens and not to prevent or allow a mbo delete. We should leverage the \"can delete\" event for that.\n\n#### Before Save, After Save and After Commit Event in Object Launch Point\n75 Scripting supported only the “Before Save” events in the Object Launchpoint. Although that is\nthe most common place where we do customizations, we often see the need to attach some\ncustomizations at the after save and after commit events - mostly when we are doing some\nactions that need to be done after the Mbo has been saved or committed. After save is the\nphase when the Mbo’s sql statement (insert/update/delete) has been fired, but the commit has\nnot happened. After commit stage happens when the Mbo in the transaction has been\ncommitted ie the database commit has been successfully executed.\nAfter save is events are good for writing to an external storage. For example - Maximo\nIntegration Events are processed at the after save event. In this phase if the write fails, we can\nalways roll back the Mbo transaction. Also at this stage - all Mbo validations have passed and hence the chances of failure due to Maximo business logic failure is very low.\n\n\nAfter commit events are good for actions that require your Maximo data to be commited. For\nexample you may want to send an SMS only when an Asset has been reported “BROKEN”.\nYou can access the \"mbo\" variable at all of the script points here.\n\n### Can Add Event\nWe can control whether we can add a Mbo using scripting Object Launchpoint \"Allow Object Creation\".\nThis is an Object Launch Point - \"Allow Object Creation\" where you can control whether you can\nadd a new Mbo, given the current state of the system. This point pairs up with the canAdd callback that we have in the MboSet\nframework.\n\n\nLets take a use case where we want to validate that a POLINE can be added to a PO only when\nthe PO has the vendor information set.\nThe script code to do that is shown below:\n\n```python\nif mboset.getOwner() is not None and mboset.getOwner().getName()==\"PO\" and mboset.getOwner().isNull(\"vendor\"):\n  service.error(\"po\",\"novendor_noline\")\n```\nNote that here, there is no implicit variable called \"mbo\" as the launch point is invoked before\nthe Mbo is created. At that point all you have is the MboSet (implicit variable \"mboset\") for the POLINE.\nIf you are wondering why this cannot be done using the init Object launch point, the answer is\nthat its little too late. At that point the Mbo has already been created and added to the set. Rejecting it at the point would have not helped.\nAlso note the usage of the global \"service\" variable here to throw the error in real time. This effectively replaces setting the errorgrp and\nerrorkey variables to throw error.\n\n### Can Delete Event\nSimilar to the \"Can Add\", this Object Launch Point helps validate whether a Mbo can be deleted\nor not. Going with the POLINE object, say we want to enforce a validation that the line should\nnot be deleted, if the PO is of priority 1.\n\n```python\nif mbo.getOwner() is not None and mbo.getOwner().getName()==\"PO\" and !mbo.getOwner().isNull(\"priority\") and and mbo.getOwner().getInt(\"priority\")==1:\n  service.error(\"po\",\"nolinedelete_forpriority1\")\n```\nNote that in this case, the mbo is already there (which we are trying to validate for deletion) and\nhence we can leverage implicit variable mbo to do the validation.\n\n\n### Adding validation to the virtual (aka Nonpersistent) mbos (on execute)\n\nIn this sample we are going use the change status dialog from the Asset Application to validate\nif the memo is filled in when the Asset status is set to BROKEN.  \n\n\nWe will write a Object launch point script – MEMOREQD, which will validate on OK button press\nof the dialog that memo is required for status BROKEN. The event will be “save/add”. This will\nmap to the “execute” call back for Nonpersistent mbos. The object name would be\nASCHANGESTATUS. We used Python for this sample.  \n\n\n```python\nif mboset.getMbo(0).getString(\"status\")==\"BROKEN\" and mboset.getMbo(0).isNull(\"pluscmemo\"):\n  service.error(\"memo\",\"reqd\")\n```\n\nNote the use of the `mboset` variable, which is leveraged to get the current Mbo at 0 index. Now\ntry the change status dialog to see if it throws the memo#reqd error when you do not specify the\n\"memo\" for BROKEN.\n\n\n### Adding setup logic for virtual (aka Nonpersistent) mbos (on setup)\n\nNonpersistent mbosets will get a callback from the Maximo framework for loading the mbos from whatever data \nsource the application programmer planned on using to load the data for this mboset. We have a script point to handle this very use case.\nThe Object \"init\" launch point event for non-persistent objects would provide 2 callbacks. The first callback would be for this \"setup\" event. \nThe script developer can check for the `onsetup` implicit variable (boolean). For setup events, this variable will be set to true. The script can then use the \n`mboset` variable to fill it up with mbos. Note that this script point executes after the mbosets default setup has been called. There is not script point for a \"before setup\" event.\n\n```python\nif onsetup:\n  mbo = mboset.add()\n  mbo.setValue(\"attr1\",\"value1\")\n  mbo.setValue(\"attr2\",\"value2\")\n```\n\nThe above example shows how the \"setup\" event is leveraged to set up the non-persistent mbo. One can use a loop to setup the set with multiple mbo records too.\n\n","fileAbsolutePath":"/home/sls/git/maximo-app-framework/maximo-autoscript-documentation/src/pages/objectscripts/objectlaunch.mdx"}}},
    "staticQueryHashes": ["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}
{
    "componentChunkName": "component---src-pages-objectscripts-objectlaunch-mdx",
    "path": "/objectscripts/objectlaunch/",
    "result": {"pageContext":{"frontmatter":{"title":"Object launch point"},"relativePagePath":"/objectscripts/objectlaunch.mdx","titleType":"append","MdxNode":{"id":"e7033b5d-491d-552b-b1ba-ccfc188f6415","children":[],"parent":"ebc8d735-6a6c-5287-94c0-d507b45d745f","internal":{"content":"---\ntitle: Object launch point\n---\n\n## Object launch point\nThis launch point lets you invoke scripts for the MBO events, init and save point ones, add, update and delete. \nIn addition to those events, this launch point also taps into the pre-add or `can add` and pre-delete `can delete` events which can control whether an MBO can be added or deleted. \nA launch point can be configured to listen to one or more of these events at the\nsame time. The script will have access to the event MBO using the implicit variable\n`mbo', the MboSet as well as all the related MBOs.\nTo design scripts using Object launch point, start the following **Create Scripts with Object Launch Point** wizard:\n\n![Object Launchpoint UI](olpui.jpg)\n\n### Init event\nThe initialization event based scripts can\nbe used to set calculated fields, set fields as readonly, required, hidden or set\nconditional defaults to MBO attributes. The save point event-based scripts can be\nused to implement save point object validations as well as save point actions.\nThe following example will demonstrate an initialization point script and the next\none would demonstrate a save point script.\nSuppose you want to customize the Asset application to display the\ntotal spare part quantity in a new non-persistent Asset object attribute called\nsparepartqty. This boils down to the requirement, whenever an Asset MBO gets\ninitialized the sparepartqty will display the sum of all the spare part quantities\nassociated with that asset. So it is evident that it will be a Object Launch Point for the object Asset and you must attach\nthe script to the initialization event of the Asset object. \nTo do this,  you should launch the **Create Scripts with Object Launch Point** wizard.\nOnce the wizard is launched the first thing you do is to create a launch point as shown in the following screenshot. The “initialize” event is what you want to use for launching\nthis script.\n\n![Object Init Event](olpuipage1.jpg)\n\nYou will need variables for this customization. First, there is a variable called sptqt which binds to the new Asset MBO attribute\nsparepartqty. All you must do is set the value of this attribute and therefore this\nvariable would be of type OUT. Next you should get all the quantities from the\nrelated Sparepart MBOs of the Asset. To do that you use the array variable\nnotation `*` to get an array of quantity values from the related sparepart MboSet.\nConsider that the array variable is qtys and its bind value would be `<asset to\nsparepart relation name>.<attribute name>*` which is `sparepart.quantity*`. The `*`\nat the end indicates the array nature of this variable and also instructs\nthe framework to form the array using the specified relationship.\n\n![Object Init Event](olpuipage2.jpg)\n\nArray variables are always of type IN and that is perfect\nfor this as you are not modifying the quantities, but you are merely summing that up.\nSo with these basic variables defined you will now attempt to write the following script:\n\n```python\nif qtys is not None:\n  sptqt = sum(qtys)\n```\n\nIt is a two-line script, which validates if there are in fact sparepart MBOs and if they exist, then sum them up and set it to the sptqt variable. The scripting framework\npicks that up and sets the value back to the binding of the sptqt or sparepartqty.\nSo the amount of Java coding done here is nothing, because it is a pure jyhton\nscript. Now going by the nature of the calculated fields, the sparepartqty should\nbe always read-only. The script is the best place to set it to read-only, which embodies the Asset initialization event. The following final script\nadds the code to set the sparepartqty attribute to read-only.\n\n```python\nsptqt_readonly=True\nif qtys is not None:\n  sptqt = sum(qtys)\n```\nOnce you click **Create** in the last wizard step to create the script, a\nsuccessful creation of the script and the launch point will generate the following response:\n\n![Launch point create confirmation](lpcreate.jpg)\n\nIn case of a compilation error you would be forced to stay back on the last page until you cancel or fix this script.\n\nThe benefit of the implicit variable concept is that when you bound sptqt\nto sparepartqty attribute, the scripting framework injected not only the\nvariable sptqt at run time, but also some implicit variables like sptqt_readonly, sptqt_required\nand sptqt_hidden. Each of these variables are of type boolean and caters to the read-only,\nrequired, and hidden flags of the MBO attribute.\n\nAnother way to do the same is by leveraging the MBO APIs:\n\n```python\nfrom psdi.mbo import MboConstants\nmbo.setValue(\"sparepartqty\",mbo.getMboSet(\"SPAREPART\").sum(\"quantity\"))\nmbo.setFieldFlag(\"sparepartqty\",MboConstants.READONLY, true)\n```\n\n\n### App Validate event\n\n\nLeverage this Object launch point to do the validation routines for the full object. Compared to the Attribute launch point \"validate\" event, \nwhich is geared towards individual attribute validations, this point offers the full MBO to validate. The implicit variables available at this script point are identical\nto the ones available for the save event, which is the \"before save\" script point. It is recommended to leverage this point for validation compared to the \"before save\" script point.\nOften application/framework code will call the MBO validate routine. In such cases, this script point is going to get invoked and the \"before save\" will not be invoked. \nSo while the before save is good to handle save point actions, validation should ideally be handled in this script point.\n\n\n### Save event\nSave point validations will help demonstrate more features of this framework.   \n\n\n#### On Add\nThe use case here is a need to customize the Asset MBO to enforce a\nnaming convention for assets [assetnum] based on their types [assettype]. This\neffectively boils down to the requirement that **whenever we are creating Assets**\nwe have to follow a naming convention for the assetnum. The key words here\nare in blocks which help us identify the launch point type and the event point in\nthat type. It is an object launch point for the Asset MBOs add event. So you should use the\nObject Launch point wizard to create and deploy this custom logic. To start with\nYou must figure out the variables and their bindings. From the requirement it is\nclear that you require the two input values from the assetnum and assettype. So there are\nTwo IN variables called anum and atype which are bound to those attributes\nrespectively. Those are the only two variables that youneed to do this task. The following script code [in Jython] is a demonstration::\n\n```python\nif atype_internal=='FACILITIES' and not anum.startswith('FT'):\n  service.error('asset','invalidassetprefix',['FT'])\nelif atype_internal=='FLEET' and not anum.startswith('FL'):\n  service.error('asset','invalidassetprefix',['FL'])\nelif atype_internal=='IT' and not anum.startswith('IT'):\n  service.error('asset','invalidassetprefix',['IT'])\nelif atype_internal=='PRODUCTION' and not anum.startswith('PR'):\n  service.error('asset','invalidassetprefix',['PR'])\n```\n\nThis could also be achieved without defining those variables and just using the implicit variable `mbo` and leveraging the Maximo SDK for internal values in the following way:\n\n```python\nfrom psdi.server import MXServer\natypeinternal = MXServer.getMXServer().getMaximoDD().getTranslator().toInternalString('ASSETTYPE', mbo.getString('assettype'));\nanum=mbo.getString('assetnum')\n```\nThe scripting framework is used to support another way to throw errors by setting the implicit variables `errorkey`,`errorgroup` and `params`. This way has been deprecated as it was not real-time. When the script code is executing the exception would be thrown only\nafter the script code has completed execution. At the end of the script execution, the framework would detect that an error flag is set and it will throw the\ncorresponding Maximo exception for that error group or key combination. So you should consider the fact that even after setting the error flags in the script, the\nscript execution will continue, unless you have adequate checks in your script code to bypass that code, if the error flag is set. \nThis is not the recommended approach and instead you should use the real-time error approach.  \n\n\nAnother way to throw error would have been to use the following MXException API directly:\n\n```python\nfrom psdi.util import MXApplicationException\n\nif <some condition>:\n  params = [prefix,assettype]\n  raise MXApplicationException('asset','invalidassetprefix', params)\n```\n\nAs before the scripting framework takes care of all the plumbing behind the scenes. Once you are done submitting your script using the wizard you can\ncome to the Asset app and try to save a test asset. You should see  that your validation routine gets executed immediately without restarting, rebuilding, or redeploying.\n\n#### On Update\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for MBO updates. \n\n#### On Delete\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for MBO updates. \nOn Delete should be leveraged to customize business logic when an MBO delete happens and not to prevent or allow an MBO delete. You should leverage the \"can delete\" event for that.\n\n#### Before Save, After Save and After Commit Event in Object Launch Point\nScripting in Maximo 7.5 supported only the “Before Save” events in the Object launch point. Although that is\nthe most common place for customizations, it may be necessary to attach some\ncustomizations at the after save and after commit events, mostly when you are doing some\nactions that need to be done after the MBO has been saved or committed. After save is the\nphase when the MBO’s sql insert, update, or delete statement has been triggered, but the commit has\nnot happened. The commit stage happens, when the MBO in the transaction has been\ncommitted or the database commit has been successfully executed.\nAfter save events are good for writing to an external storage. For example, Maximo\nIntegration Events are processed at the after save event. In this phase if the write fails, you can\nalways roll back the MBO transaction. Also at this stage, all MBO validations have passed and hence the chances of failure due to Maximo business logic failure is very low.\n\n\nAfter commit events are good for actions that require your Maximo data to be committed. For\nexample, you may want to send an SMS only when an Asset has been reported “BROKEN”.\nYou can access the \"mbo\" variable at all of the script points here.\n\n### Can Add Event\nYou can control whether you can add an MBO using scripting Object Launch point \"Allow Object Creation\".\n\"Allow Object Creation\" is an Object Launch point where you can control whether you can\nadd a new MBO, given the current state of the system. This point pairs up with the canAdd callback  in the MboSet framework.\n\n\nIf you want to validate that a POLINE can be added to a PO only when\nthe PO has the vendor information set, use the following \nscript code:\n\n```python\nif mboset.getOwner() is not None and mboset.getOwner().getName()==\"PO\" and mboset.getOwner().isNull(\"vendor\"):\n  service.error(\"po\",\"novendor_noline\")\n```\nThere is no implicit variable called \"mbo\" as the launch point is invoked before\nthe MBO is created. At that point all you have is the MboSet (implicit variable \"mboset\") for the POLINE.\nIf you are wondering why this cannot be done using the init Object launch point, the answer is\nthat it is too late. At this point, the MBO has already been created and added to the set. Rejecting it at this point will not be helpful.\nAlso, the usage of the global \"service\" variable to throw the error in real time effectively replaces setting the errorgrp and errorkey variables to throw error.\n\n### Can Delete Event\nSimilar to the \"Can Add\", this Object Launch Point helps validate whether an MBO can be deleted\nor not. Going with the POLINE object, for example, you want to enforce a validation that the line should not be deleted, if the PO is of priority 1, you can use the following code:\n\n```python\nif mbo.getOwner() is not None and mbo.getOwner().getName()==\"PO\" and !mbo.getOwner().isNull(\"priority\") and and mbo.getOwner().getInt(\"priority\")==1:\n  service.error(\"po\",\"nolinedelete_forpriority1\")\n```\nIn this case, the MBO, which we are trying to validate for deletion is already there, and\nhence we can leverage the implicit variable MBO to do the validation.\n\n\n### Adding validation to the virtual (aka Nonpersistent) MBOs (on execute)\n\nIn this sample you are going use the change status dialog from the Asset Application to validate\nif the memo is filled in when the Asset status is set to BROKEN.  \n\n\nYou will write an Object launch point script, MEMOREQD, which will validate that a memo is required for status BROKEN, on clicking **OK**. The event will be “save/add”. This will\nmap to the “execute” call back for Nonpersistent MBOs. The object name would be\nASCHANGESTATUS. The following sample uses Python.  \n\n\n```python\nif mboset.getMbo(0).getString(\"status\")==\"BROKEN\" and mboset.getMbo(0).isNull(\"pluscmemo\"):\n  service.error(\"memo\",\"reqd\")\n```\n\nThe `mboset` variable is leveraged to get the current MBO at 0 index. Now you can\ntry the change status dialog to see if it throws the memo#reqd error when you do not specify the\n\"memo\" for BROKEN.\n\n\n### Adding setup logic for virtual (aka Nonpersistent) MBOs (on setup)\n\nNon-persistent MBOSETS will get a callback from the Maximo framework for loading the MBOs from whatever data source the application programmer planned on using to load the data for this MBOSET. There is a script point to handle this very use case.\nThe Object \"init\" launch point event for non-persistent objects would provide two callbacks. The first callback would be for this \"setup\" event. \nThe script developer can check for the `onsetup` implicit variable (boolean). For setup events, this variable will be set to true. The script can then use the \n`mboset` variable to fill it up with MBOs. The script point executes after the MBOSETS default setup has been called. There is no script point for a \"before setup\" event.\n\n```python\nif onsetup:\n  mbo = mboset.add()\n  mbo.setValue(\"attr1\",\"value1\")\n  mbo.setValue(\"attr2\",\"value2\")\n```\n\nThe example shows how the \"setup\" event is leveraged to set up the non-persistent MBO. You can use a loop to setup the set with multiple MBO records too.\nThis `setup` callback is not turned on by default, for backward compatibility. To turn it on, set the Maximo property `mxe.script.callsetuponinit` to 1. \nSince the script cache must get refreshed for this property change to take effect, it is recommended to bounce the Maximo server instances for this or refresh the script cache by modifying the script. For example, you can update the description of the script.\n","type":"Mdx","contentDigest":"e8eaee452e95b9baf312adc2f89d4c99","owner":"gatsby-plugin-mdx","counter":205},"frontmatter":{"title":"Object launch point"},"exports":{},"rawBody":"---\ntitle: Object launch point\n---\n\n## Object launch point\nThis launch point lets you invoke scripts for the MBO events, init and save point ones, add, update and delete. \nIn addition to those events, this launch point also taps into the pre-add or `can add` and pre-delete `can delete` events which can control whether an MBO can be added or deleted. \nA launch point can be configured to listen to one or more of these events at the\nsame time. The script will have access to the event MBO using the implicit variable\n`mbo', the MboSet as well as all the related MBOs.\nTo design scripts using Object launch point, start the following **Create Scripts with Object Launch Point** wizard:\n\n![Object Launchpoint UI](olpui.jpg)\n\n### Init event\nThe initialization event based scripts can\nbe used to set calculated fields, set fields as readonly, required, hidden or set\nconditional defaults to MBO attributes. The save point event-based scripts can be\nused to implement save point object validations as well as save point actions.\nThe following example will demonstrate an initialization point script and the next\none would demonstrate a save point script.\nSuppose you want to customize the Asset application to display the\ntotal spare part quantity in a new non-persistent Asset object attribute called\nsparepartqty. This boils down to the requirement, whenever an Asset MBO gets\ninitialized the sparepartqty will display the sum of all the spare part quantities\nassociated with that asset. So it is evident that it will be a Object Launch Point for the object Asset and you must attach\nthe script to the initialization event of the Asset object. \nTo do this,  you should launch the **Create Scripts with Object Launch Point** wizard.\nOnce the wizard is launched the first thing you do is to create a launch point as shown in the following screenshot. The “initialize” event is what you want to use for launching\nthis script.\n\n![Object Init Event](olpuipage1.jpg)\n\nYou will need variables for this customization. First, there is a variable called sptqt which binds to the new Asset MBO attribute\nsparepartqty. All you must do is set the value of this attribute and therefore this\nvariable would be of type OUT. Next you should get all the quantities from the\nrelated Sparepart MBOs of the Asset. To do that you use the array variable\nnotation `*` to get an array of quantity values from the related sparepart MboSet.\nConsider that the array variable is qtys and its bind value would be `<asset to\nsparepart relation name>.<attribute name>*` which is `sparepart.quantity*`. The `*`\nat the end indicates the array nature of this variable and also instructs\nthe framework to form the array using the specified relationship.\n\n![Object Init Event](olpuipage2.jpg)\n\nArray variables are always of type IN and that is perfect\nfor this as you are not modifying the quantities, but you are merely summing that up.\nSo with these basic variables defined you will now attempt to write the following script:\n\n```python\nif qtys is not None:\n  sptqt = sum(qtys)\n```\n\nIt is a two-line script, which validates if there are in fact sparepart MBOs and if they exist, then sum them up and set it to the sptqt variable. The scripting framework\npicks that up and sets the value back to the binding of the sptqt or sparepartqty.\nSo the amount of Java coding done here is nothing, because it is a pure jyhton\nscript. Now going by the nature of the calculated fields, the sparepartqty should\nbe always read-only. The script is the best place to set it to read-only, which embodies the Asset initialization event. The following final script\nadds the code to set the sparepartqty attribute to read-only.\n\n```python\nsptqt_readonly=True\nif qtys is not None:\n  sptqt = sum(qtys)\n```\nOnce you click **Create** in the last wizard step to create the script, a\nsuccessful creation of the script and the launch point will generate the following response:\n\n![Launch point create confirmation](lpcreate.jpg)\n\nIn case of a compilation error you would be forced to stay back on the last page until you cancel or fix this script.\n\nThe benefit of the implicit variable concept is that when you bound sptqt\nto sparepartqty attribute, the scripting framework injected not only the\nvariable sptqt at run time, but also some implicit variables like sptqt_readonly, sptqt_required\nand sptqt_hidden. Each of these variables are of type boolean and caters to the read-only,\nrequired, and hidden flags of the MBO attribute.\n\nAnother way to do the same is by leveraging the MBO APIs:\n\n```python\nfrom psdi.mbo import MboConstants\nmbo.setValue(\"sparepartqty\",mbo.getMboSet(\"SPAREPART\").sum(\"quantity\"))\nmbo.setFieldFlag(\"sparepartqty\",MboConstants.READONLY, true)\n```\n\n\n### App Validate event\n\n\nLeverage this Object launch point to do the validation routines for the full object. Compared to the Attribute launch point \"validate\" event, \nwhich is geared towards individual attribute validations, this point offers the full MBO to validate. The implicit variables available at this script point are identical\nto the ones available for the save event, which is the \"before save\" script point. It is recommended to leverage this point for validation compared to the \"before save\" script point.\nOften application/framework code will call the MBO validate routine. In such cases, this script point is going to get invoked and the \"before save\" will not be invoked. \nSo while the before save is good to handle save point actions, validation should ideally be handled in this script point.\n\n\n### Save event\nSave point validations will help demonstrate more features of this framework.   \n\n\n#### On Add\nThe use case here is a need to customize the Asset MBO to enforce a\nnaming convention for assets [assetnum] based on their types [assettype]. This\neffectively boils down to the requirement that **whenever we are creating Assets**\nwe have to follow a naming convention for the assetnum. The key words here\nare in blocks which help us identify the launch point type and the event point in\nthat type. It is an object launch point for the Asset MBOs add event. So you should use the\nObject Launch point wizard to create and deploy this custom logic. To start with\nYou must figure out the variables and their bindings. From the requirement it is\nclear that you require the two input values from the assetnum and assettype. So there are\nTwo IN variables called anum and atype which are bound to those attributes\nrespectively. Those are the only two variables that youneed to do this task. The following script code [in Jython] is a demonstration::\n\n```python\nif atype_internal=='FACILITIES' and not anum.startswith('FT'):\n  service.error('asset','invalidassetprefix',['FT'])\nelif atype_internal=='FLEET' and not anum.startswith('FL'):\n  service.error('asset','invalidassetprefix',['FL'])\nelif atype_internal=='IT' and not anum.startswith('IT'):\n  service.error('asset','invalidassetprefix',['IT'])\nelif atype_internal=='PRODUCTION' and not anum.startswith('PR'):\n  service.error('asset','invalidassetprefix',['PR'])\n```\n\nThis could also be achieved without defining those variables and just using the implicit variable `mbo` and leveraging the Maximo SDK for internal values in the following way:\n\n```python\nfrom psdi.server import MXServer\natypeinternal = MXServer.getMXServer().getMaximoDD().getTranslator().toInternalString('ASSETTYPE', mbo.getString('assettype'));\nanum=mbo.getString('assetnum')\n```\nThe scripting framework is used to support another way to throw errors by setting the implicit variables `errorkey`,`errorgroup` and `params`. This way has been deprecated as it was not real-time. When the script code is executing the exception would be thrown only\nafter the script code has completed execution. At the end of the script execution, the framework would detect that an error flag is set and it will throw the\ncorresponding Maximo exception for that error group or key combination. So you should consider the fact that even after setting the error flags in the script, the\nscript execution will continue, unless you have adequate checks in your script code to bypass that code, if the error flag is set. \nThis is not the recommended approach and instead you should use the real-time error approach.  \n\n\nAnother way to throw error would have been to use the following MXException API directly:\n\n```python\nfrom psdi.util import MXApplicationException\n\nif <some condition>:\n  params = [prefix,assettype]\n  raise MXApplicationException('asset','invalidassetprefix', params)\n```\n\nAs before the scripting framework takes care of all the plumbing behind the scenes. Once you are done submitting your script using the wizard you can\ncome to the Asset app and try to save a test asset. You should see  that your validation routine gets executed immediately without restarting, rebuilding, or redeploying.\n\n#### On Update\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for MBO updates. \n\n#### On Delete\nThis is similar to the \"on add\" with all the implicit variables remaining the same. Use this to customize the business logic for MBO updates. \nOn Delete should be leveraged to customize business logic when an MBO delete happens and not to prevent or allow an MBO delete. You should leverage the \"can delete\" event for that.\n\n#### Before Save, After Save and After Commit Event in Object Launch Point\nScripting in Maximo 7.5 supported only the “Before Save” events in the Object launch point. Although that is\nthe most common place for customizations, it may be necessary to attach some\ncustomizations at the after save and after commit events, mostly when you are doing some\nactions that need to be done after the MBO has been saved or committed. After save is the\nphase when the MBO’s sql insert, update, or delete statement has been triggered, but the commit has\nnot happened. The commit stage happens, when the MBO in the transaction has been\ncommitted or the database commit has been successfully executed.\nAfter save events are good for writing to an external storage. For example, Maximo\nIntegration Events are processed at the after save event. In this phase if the write fails, you can\nalways roll back the MBO transaction. Also at this stage, all MBO validations have passed and hence the chances of failure due to Maximo business logic failure is very low.\n\n\nAfter commit events are good for actions that require your Maximo data to be committed. For\nexample, you may want to send an SMS only when an Asset has been reported “BROKEN”.\nYou can access the \"mbo\" variable at all of the script points here.\n\n### Can Add Event\nYou can control whether you can add an MBO using scripting Object Launch point \"Allow Object Creation\".\n\"Allow Object Creation\" is an Object Launch point where you can control whether you can\nadd a new MBO, given the current state of the system. This point pairs up with the canAdd callback  in the MboSet framework.\n\n\nIf you want to validate that a POLINE can be added to a PO only when\nthe PO has the vendor information set, use the following \nscript code:\n\n```python\nif mboset.getOwner() is not None and mboset.getOwner().getName()==\"PO\" and mboset.getOwner().isNull(\"vendor\"):\n  service.error(\"po\",\"novendor_noline\")\n```\nThere is no implicit variable called \"mbo\" as the launch point is invoked before\nthe MBO is created. At that point all you have is the MboSet (implicit variable \"mboset\") for the POLINE.\nIf you are wondering why this cannot be done using the init Object launch point, the answer is\nthat it is too late. At this point, the MBO has already been created and added to the set. Rejecting it at this point will not be helpful.\nAlso, the usage of the global \"service\" variable to throw the error in real time effectively replaces setting the errorgrp and errorkey variables to throw error.\n\n### Can Delete Event\nSimilar to the \"Can Add\", this Object Launch Point helps validate whether an MBO can be deleted\nor not. Going with the POLINE object, for example, you want to enforce a validation that the line should not be deleted, if the PO is of priority 1, you can use the following code:\n\n```python\nif mbo.getOwner() is not None and mbo.getOwner().getName()==\"PO\" and !mbo.getOwner().isNull(\"priority\") and and mbo.getOwner().getInt(\"priority\")==1:\n  service.error(\"po\",\"nolinedelete_forpriority1\")\n```\nIn this case, the MBO, which we are trying to validate for deletion is already there, and\nhence we can leverage the implicit variable MBO to do the validation.\n\n\n### Adding validation to the virtual (aka Nonpersistent) MBOs (on execute)\n\nIn this sample you are going use the change status dialog from the Asset Application to validate\nif the memo is filled in when the Asset status is set to BROKEN.  \n\n\nYou will write an Object launch point script, MEMOREQD, which will validate that a memo is required for status BROKEN, on clicking **OK**. The event will be “save/add”. This will\nmap to the “execute” call back for Nonpersistent MBOs. The object name would be\nASCHANGESTATUS. The following sample uses Python.  \n\n\n```python\nif mboset.getMbo(0).getString(\"status\")==\"BROKEN\" and mboset.getMbo(0).isNull(\"pluscmemo\"):\n  service.error(\"memo\",\"reqd\")\n```\n\nThe `mboset` variable is leveraged to get the current MBO at 0 index. Now you can\ntry the change status dialog to see if it throws the memo#reqd error when you do not specify the\n\"memo\" for BROKEN.\n\n\n### Adding setup logic for virtual (aka Nonpersistent) MBOs (on setup)\n\nNon-persistent MBOSETS will get a callback from the Maximo framework for loading the MBOs from whatever data source the application programmer planned on using to load the data for this MBOSET. There is a script point to handle this very use case.\nThe Object \"init\" launch point event for non-persistent objects would provide two callbacks. The first callback would be for this \"setup\" event. \nThe script developer can check for the `onsetup` implicit variable (boolean). For setup events, this variable will be set to true. The script can then use the \n`mboset` variable to fill it up with MBOs. The script point executes after the MBOSETS default setup has been called. There is no script point for a \"before setup\" event.\n\n```python\nif onsetup:\n  mbo = mboset.add()\n  mbo.setValue(\"attr1\",\"value1\")\n  mbo.setValue(\"attr2\",\"value2\")\n```\n\nThe example shows how the \"setup\" event is leveraged to set up the non-persistent MBO. You can use a loop to setup the set with multiple MBO records too.\nThis `setup` callback is not turned on by default, for backward compatibility. To turn it on, set the Maximo property `mxe.script.callsetuponinit` to 1. \nSince the script cache must get refreshed for this property change to take effect, it is recommended to bounce the Maximo server instances for this or refresh the script cache by modifying the script. For example, you can update the description of the script.\n","fileAbsolutePath":"/home/travis/build/maximo-app-framework/maximo-autoscript-documentation/src/pages/objectscripts/objectlaunch.mdx"}}},
    "staticQueryHashes": ["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}
{
    "componentChunkName": "component---src-pages-integration-osevents-mdx",
    "path": "/integration/osevents/",
    "result": {"pageContext":{"frontmatter":{"title":"Object Structure Scripting"},"relativePagePath":"/integration/osevents.mdx","titleType":"append","MdxNode":{"id":"b01f2a43-495e-57e1-8220-5369e5b95229","children":[],"parent":"3abee0f1-ead3-58f6-b54a-2df56662d727","internal":{"content":"---\ntitle: Object Structure Scripting\n---\n\nThe Object Structure provides the message definition and content for other integration components like the Publish Channel. In addition, the object structure by itself can support the exchange of Maximo data with external applications/clients via REST, for example. Using a script on the object structure applies to all uses as shown in the diagram below.\n\n\n![OS use cases](osusecase.jpg)\n\n\nA script on an object structure such as MXITEM, can impact the processing of item data through REST, application Import, Enterprise Service and Invocation/Publish Channel.\n\n## Creating a Script\n\nThe 4 screen shots below identify the steps to create a new script for use with integration. This example will create a script for the MXITEM object structure that would run during the inbound processing.\n\n![OS script](osscript.jpg)\n\n![OS script name](osscriptname.jpg)\n\n![OS script code](osscriptcode.jpg)\n\n\n## Object Structure Script Processing - Inbound\n\nThe framework that supports the inbound processing of an object structure provides methods, or hooks, where custom Java code can be implemented to alter or enhance the processing of the data through the object structure to the Maximo business objects (MBOs).  With the introduction of scripting, these same functions, or hooks, are available to use by an automation script to perform similar customizations that can be done using Java.  In the case of the processing of Object Structures, a custom Java class and a custom automation script can be implemented on one object structure at the same time (Note: this does not apply to all integration components).\n\nThe inbound processing of an object structure provides a number of predefined methods, or functions, that must be extended by an automation script in order to implement custom processing via a script.  These functions support implementing logic at different points in the processing of message into Maximo.\n\n### Prior to any MBO processing\n\n|Function|\n|:--------------------------------|\n|beforeProcess(ctx)|\n\n\nThis function would be processed once for each noun in the inbound message. If the \tinbound message had 5 items, each item would be considered a noun.\n\n### During the processing of MBOSets and MBOs\n\n|Function|\n|:--------------------------------|\n|beforeCreateMboSet(ctx)|\n|afterCreateMboSet(ctx)|\n|mboRules(ctx)|\n|beforeMboData(ctx)|\n|afterMboData(ctx)|\n\n\nThese functions would be processed sequentially for each object within every noun \tin the inbound message.  If the object structure for an item contained the Item \tobject and the itemspec object, the functions above would process sequentially for \titem and then itemspec.\n\n\n### After the MBO processing\n\n|Function|\n|:--------------------------------|\n|preSaveRules(ctx)|\n|changeStatus(ctx)|\n\n\nThese functions would be processed once for each noun in the inbound message.\n\n\nThere is a context (ctx) that is passed between the processing of the object structure and the script in order for the script to implement custom code. This context is supported bi-directionally. There are pre-defined APIs available on the context:\n\n### Context (ctx) Apis\nThe matrix below outlines the apis (column on left) and their most common uses within the available functions (row across the top).\n\n\n![OS script](osinmatrix.jpg)  \n\n\nThe `ctx` variable is explained below. Note that some cases are applicable to both inbound and outbound and some of them are specific to either inbound or outbound.\n\n\n\n|Context Function|Description|Applicability|\n|:-----------|:-----------------------------------------------------------------|:-------------------|\n|ctx.getMosDetailInfo()|this provides the integration data dictionary cache information for the object in the the object structure being processed.|Inbound and outbound|\n|ctx.skipMbo()|this supports the skipping of a MBO (i.e. don’t process) on the inbound/outbound message|Inbound and outbound|\n|ctx.skipTxn()|this supports the skipping an entire transaction (i.e. message) from processing|Inbound and outbound|\n|ctx.complete()|this supports ending the processing at the point of execution – will not process the children data of the message|Inbound and outbound|\n|ctx.process()|this supports continuing the processing at the point of execution – likely used as part of conditional logic|Inbound and outbound|\n|ctx.getParentMbo()|retrieves the parent mbo – can be used from a child that does not yet have a mbo created.|Inbound|\n|ctx.isPrimary()|identifies if the current mbo is the root level mbo of the object structure|Inbound|\n|ctx.getUserInfo()|supports the retrieval of the user info.This would be needed for a script to create a new mbo|Inbound and outbound|\n|ctx.bypassMbo()|supports by-passing the mbo creation and continuing to the next mbo to be processed. This could be used when there is a case where one mbo creates a child mbo, so the integration processing wants to bypass the creation of that child mbo|Inbound|\n|ctx.getMsgType()|provides access to the message type (Sync, Create etc).|Inbound|\n|ctx.setMsgType(String msgType)|provides support to set the message type (Sync, Create etc). Can be used before processing only|Inbound|\n|ctx.getData()|provides access to StructureData (XML message)|Inbound|\n|ctx.getMboSet()|Gets the mboset in context for the level that is getting processed now|Inbound|\n|ctx.setMboSet()|sets the mboset for the current level. This is leveraged for cases where one would want to create the mboset for that level in a custom way.|Inbound|\n|ctx.setMbo(MboRemote mbo)|this sets the mbo for the level. This is done when we want to create or find the mbo in a custom way.|Inbound|\n|ctx.getPrimaryMboSet()|this gets the primary mboset (the root object) for this object structure.|Inbound|\n|ctx.getPrimaryMbo()|provides support for retrieving the primary (root) mbos of an object structure when processing a child mbo.|Inbound|\n|ctx.setProcessTable(String processTable)|used for setting the table for a process – for example, when you have a non-persistent mbo such as MXRECEIPT, it has processing logic to determine the table(mbo) to be updated (either MATRECTRANS or SERVRECTRANS). This api should be used in the beforeProcess(ctx) function.|Inbound|\n|ctx.setSkipBaseAdditionalRules()|used in the preSaveRules(ctx) function, this can be used to inject custom logic to operate on a completed object structure that is now prepared at this point in the processing.|Inbound|\n|ctx.processAsUpdate()|Sets the processing action of a MBO to be an Update (versus an Add or Delete).|Inbound|\n|ctx.processAsAdd()|Sets the processing action of a MBO to be an Add (versus an Update or Delete).|Inbound|\n|ctx.processAsAtEnd()|Sets the processing action of a MBO to be an Add (versus an Update or Delete) and will create the MBO at the end of the collection rather than by default it would be created at the top of the MBO collection..|Inbound|\n\n\n### Inbound Script Examples using the Functions and APIs mentioned above\n\nMany of the examples below were done by enabling Application Import and Export in the Item Master application using the MXITEM object structure. \nAn item was exported and the XML was modified to a smaller set of attributes as shown below. This XML was first imported with no script to ensure it would successfully create an Item. \nOn subsequent tests, the Item Number was changed to ensure that a new record could be created (avoid duplicate errors).\n\n```xml\n?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SyncMXITEM xmlns=\"http://www.ibm.com/maximo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" creationDateTime=\"2014-10-03T15:36:12-04:00\" transLanguage=\"EN\" baseLanguage=\"EN\" messageID=\"1412364918445435277\" maximoVersion=\"7 6 20140925-2230 V7600-211\">\n  <MXITEMSet>\n    <ITEM>\n      <DESCRIPTION>Centrifugal Pump 100-1 GPM, 60 FT-HD</DESCRIPTION>\n      <HIERARCHYPATH>PUMP \\ CNTRFGL</HIERARCHYPATH>\n      <ITEMNUM>PUMP100-1</ITEMNUM>\n      <ITEMSETID>SET1</ITEMSETID>\n      <ITEMTYPE>ITEM</ITEMTYPE>\n      <LOTTYPE>NOLOT</LOTTYPE>\n      <STATUS>ACTIVE</STATUS>\n    </ITEM>\n  </MXITEMSet>\n\t</SyncMXITEM>\n\n```\n\n\n**Function: beforeProcess(ctx)** \n\n\nThis function will process prior to any MBOs being retrieved or created by the object structure processing.\nIf you are using the object structure (OS) with application import, REST/OSLC api or calling the OS using SOAP or XML over HTTP, \nthe inbound processing class is the only placeholder to inject custom code \n(if you were using an Enterprise Service you would have additional processing points for custom code).   \n\n\nIf external applications are calling the object structure but that application cannot do any filtering of messages, \nyou could implement filtering in the function using the ctx.skipTxn() api. \nImplementing filtering here is a good choice since there has been no extensive processing of the data at this point. \nA skipped transaction would avoid unnecessary processing.\nThis script will filter out any items where the LOTTYPE = NOLOT.\n\n```javascript\nfunction beforeProcess(ctx)\n{\n  var lot=ctx.getData().getCurrentData(\"LOTTYPE\")  \n  if (lot==\"NOLOT\")\n  {\n    ctx.skipTxn();\n  }\n}\n```\n\nIn the above script, the ctx.getData().getCurrentData uses the structureData api to retrieve the Lot Type value from XML message and sets it to the 'lot' variable.  \nThen a condition tests the value of the variable and calls the ctx.skipTxn() api for the framework to skip the processing of the message.  \nNote that the response of processing is still 'success' (the same as if the record was created in Maximo) since no exception was raised.  \nWhen testing a scenario like this, one way to verify the behavior of your script is to load the record with the script as active and then load again when the script is configured as not active. \nIn the test above, with the script active, there was no item added.  With the script not active, a new item was created.\n\n\n**Function: mboRules(ctx)**\n\n\nThe mboRules(ctx) function [tied to the checkBusinessRules() method of the object structure processing class]  operates prior the creation of each mbo. This can be used to skip processing of a specific mbo, transaction or continue processing.  A mbo can also be created at this point as well.\n\nThe example below is for the MXINVISSUE object structure that accepts Issue transactions of type Issue and Return but does not support type Invoice.  This script will filter out the types that are  Invoice.\n\n```javascript\nfunction mboRules(ctx)\n{\n\n  if (ctx.getMosDetailInfo().getObjectName() == \"MATUSETRANS\")\n  { \n    var type=ctx.getData().getCurrentData(\"ISSUETYPE\")\n    if (type NOT IN (\"ISSUE\",\"RETURN\"))\n    {\n      ctx.skipMbo(); \n    }\n  } \n} \n```\n\n\n**Functions:  beforeMboData(ctx) and afterMboData(ctx) **\n\nThe beforeMBOData function [tied to the presetMboRulesSet() method of the object structure processing class] is available as the MBO is being created but before MIF processing sets values to the MBO.\nThe afterMboData(ctx) [tied to the setAdditionalData() method of the object structure processing class]  is available after the MBO is created and the values are set \nto the MBO by the MIF.  The MBO data is pre-save and processing could be implemented to create additional related MBOs that would be included in the transaction or \nchange data in MBOs using custom logic.  Since the MBO columns are set by the MIF at this point, by default script processing could not set the field values.  \nIf there is a need to set the field values at this point in the processing, then you would need to configure the field as Set Restricted in the object structure so \nthat the MIF does not set this and then provide logic to set the value in your script. \nThe primary difference between the 'before' and 'after' function is that the 'before' allows your code to set a field value conditionally and when that condition is\n not met the MIF will set the field using the value in the incoming message.  The 'after' function approach will use the value your code implements and the MIF \n will not set the field (since the field will need to be Set Restricted).\n\n**beforeMboData(ctx)** Example\nBelow is an example XML message and script using the 'before' function.  The XML is a simple MXITEM xml to create a new Item in Maximo\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SyncMXITEM xmlns=\"http://www.ibm.com/maximo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <MXITEMSet>\n    <ITEM>\n      <DESCRIPTION>New Item</DESCRIPTION>\n      <HIERARCHYPATH>PUMP \\ CNTRFGL</HIERARCHYPATH>\n      <ITEMNUM>NEWITEM01</ITEMNUM>\n      <COMMODITYGROUP>MOTOR</COMMODITYGROUP>\n      <ITEMSETID>SET1</ITEMSETID>\n    </ITEM>\n  </MXITEMSet>\n</SyncMXIT\n```\n\n\nThe script below, \n1. determines that the MBO being processed is ITEM\n2. set the HIERARCHYPATH field from the message to a variable (hier).\n3. evaluates the value of the variable hier to be equal to 'PUMP \\ CNTRFLG'  \n   * if equal, it defaults the value PUMP to the Commodity Group field in the MBO. The value is set with DELAYVALIDATION so that any processing that occurs after this script executes cannot set this field value. \n   * if not equal,  the script does not set the value and the value will be set to MOTOR from the incoming message by the MIF.\n\n\n```javascript\nfunction beforeMboData(ctx)\n{\n  if (ctx.getMosDetailInfo().getObjectName() == \"ITEM\")\n  { \n    var hier=ctx.getData().getCurrentData(\"HIERARCHYPATH\")\n    if (hier == \"PUMP \\\\ CNTRFGL\")\n    {\n      var mbo = ctx.getMbo(); \n      var MboConstants = Java.type(\"psdi.mbo.MboConstants\");\n      mbo.setValue(\"commoditygroup\",\"PUMP\",MboConstants.DELAYVALIDATION);\n    }\n  } \n}\n```\n\n\n**afterMboData(ctx)** Example\nBelow is an example XML message and script using the 'after' function.  The XML is a simple MXITEM xml to create a new Item in Maximo\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SyncMXITEM xmlns=\"http://www.ibm.com/maximo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <MXITEMSet>\n    <ITEM>\n      <DESCRIPTION>New Item</DESCRIPTION>\n      <HIERARCHYPATH>PUMP \\ CNTRFGL</HIERARCHYPATH>\n      <ITEMNUM>NEWITEM01</ITEMNUM>\n      <COMMODITYGROUP>MOTOR</COMMODITYGROUP>\n      <ITEMSETID>SET1</ITEMSETID>\n    </ITEM>\n  </MXITEMSet>\n</SyncMXIT>\n```\n\n\nThe script logic below is identical to the logic used in the 'before' example above.  An additional configuration was that the Commodity Code was configured as \nSet Restricted to prevent the MIF from setting the field value.  This is needed since the MIF default processing will always set fields with 'DELAYVALIDATION'\n which prevent any subsequent processing from overriding the value set by the MIF. \n\nThe script:\n1. determines that the MBO being processed is ITEM\n2. set the HIERARCHYPATH field from the message to a variable (hier).\n3. evaluates the value of the variable hier to be equal to 'PUMP \\ CNTRFLG'  \n   * if equal, it defaults the value PUMP to the Commodity Group field in the MBO. The value is set with DELAYVALIDATION so that the any processing that occurs after this script executes cannot set this field value. \n   * if not equal,  the script does not set the value and the field will not be set when saved unless the MBO provides a default value.\n\n\n```javascript\nfunction afterMboData(ctx)\n{\n\n  if (ctx.getMosDetailInfo().getObjectName() == \"ITEM\")\n  { \n    var hier=ctx.getData().getCurrentData(\"HIERARCHYPATH\")\n    if (hier == \"PUMP \\\\ CNTRFGL\")\n    {\n      var mbo = ctx.getMbo(); \n      \n      mbo.setValue(\"commoditygroup\",\"PUMP\",MboConstants.DELAYVALIDATION);\n    }\n  } \n}\n```\n\n\nIf you need to use the afterMboData function and cannot Set Restrict the field in the object structure, there is an option to 'reset' the mbo field flag that will allow you to change the field value after it has been set by either the MIF or the MBO.  \nThe script code snippet would look like this:\n\n\n```javascript\n.\n.\nmbo.setFieldFlag(\"commoditycode\", MboConstants.NOSETVALUE, false);\nmbo.setValue(\"commoditygroup\",\"PUMP\",MboConstants.DELAYVALIDATION);\n.\n.\n```\n\n\n**Functions:  changeStatus(ctx)**\n\nThe changeStatus(ctx) function [tied to the changeStatus () method] is available to provide additional capability beyond what is provided by the MIF's \nbase class for change status (statefulMicSetIn).  Using this function requires that the processing class of the object structure has either statefulMicSetIn or a \nclass that extends statefulMicSetIn to be registered. \n\n\nExamples of where this function might be used is when \n1.\t1.the processing needs to support more than the 3 default parameters (status, memo, date) of change status.\n2.\t2.the processing needs to set the status date field rather than using the default system datetime.  Note: the MBO business logic may prevent using dates that are in the future or past, or some MBOs do not support accepting the date for a changestatus (always uses the system datetime).  The following sample was used with the MXPO object structure since the status date of the PO can be set to something other than the system date.\n\n\nThe following Java Script example will set the Memo field related to the Change Status to a string value when there is no memo value (NP_STATUSMEMO) passed in the inbound integration message.  Additionally it will set the date field to the date passed in the STATUSDATE element of the inbound message (rather than the MBO using the default system datetime).\n\n\n```javascript\nimportPackage(Packages.psdi.server);\nimportPackage(Packages.psdi.mbo);\n\nfunction changeStatus(ctx)\n{\n     var mbo = ctx.getMbo();\n     var struc = ctx.getData();\n     var stat = struc.getCurrentData(\"STATUS\");\n     var statdate = struc.getCurrentDataAsDate(\"STATUSDATE\");\n     var memo = struc.getCurrentData(\"NP_STATUSMEMO\");\n     if(struc.isCurrentDataNull(\"NP_STATUSMEMO\"))\n     {\n        memo = \"Status change via Integration\";\n     }\n    mbo.changeStatus(stat, statdate, memo, MboConstants.NOACCESSCHECK);\n}\n```\n\n\nWhen script executes changeStatus, this will prevent the processing class on the object structure from executing it as well (executes only once).\n\n\n## Object Structure Script Processing - Outbound\n\n\nIts often required to manipulate the XML/JSON data serialization in the Integration Object\nstructure layer. Take the case of outbound messages where the Object structure processing\nwould serialize the Mbo structure into a XML or json message. Some of the common use cases\nare listed below:\n\n* To override certain values in the xml or json based on the current mbo state.\n* Another use case maybe to skip some mbos or attributes based on certain conditions.\n\nYou may think that you can do it in exits. However exits are further down the line in outbound\nprocessing and may-not be very efficient to let the data get serialized to json/xml and then get\ndropped. The below example in py shows the 3 functions one can define to interface with the\nObject structure serialization process. The 3 methods are listd below:\n\n\n|Function|Purpose|\n|:--------------|:---------------------------------------------------------|\n|overrideValues(ctx)|Used for the purpose of overriding the mbo attribute values as they get serialized to json/xml|\n|skipMbo(ctx)|Used for the purpose of skipping the Mbos before serialization. These skipped mbos will not be part of the xml/json generated|\n|skipCols(ctx)|Used for skipping mbo attributes before serialization.|\n\nNote that all these functions take in a common parameter ie the ctx - which is an object of type\npsdi.iface.mos.OSDefnScriptContext (refer to the table where we describe all `ctx` functions for outbound). \nThis object contains the state of the serialization and helps the script code to figure out at what level (in the Object structure hierarchy) \nwe are at the point of that call back.\n\nThe code below can be applied to the MXPO object structure - outbound. \n\n\n```python\ndef overrideValues(ctx):\n  if ctx.getMboName()=='PO' and ctx.getMbo().isNull(\"description\")==True:\n    ctx.overrideCol(\"DESCRIPTION\",\"PO \"+ctx.getMbo().getString(\"ponum\"))\n\ndef skipMbo(ctx):\n  if ctx.getMboName()=='PO':\n    if ctx.getMbo().getMboSet(\"poline\").count()==0:\n      ctx.skipTxn()\n  elif ctx.getMboName()=='POLINE':\n    if ctx.getMbo().isNull(\"itemnum\"):\n      ctx.skipMbo()\n\ndef skipCols(ctx):\n  if ctx.getMboName()=='POLINE':\n    if ctx.getMbo().getBoolean(\"taxed\")!=True:\n      ctx.skipCol(['tax1','tax2','tax3','tax4','tax5'])\n```\n\nThe points to note here are:\n1. 1.In the override cols note that we are overriding the description only when the object is\nPO and the description is null. This will not change the PO mbo description. It will just\nhave the description in the json/xml.\n2. 2.In the skipMbo thing we are will skip the poline processing if line is a service line. We are\nalso going to skip the PO itself if there are no lines for it.\n3. 3.In the skipCols we check for the mbo in process to be POLINE and if taxed is set to\nfalse, we skip all the tax attributes.\n4. 4.These ctx vars all extend the “service” global var and hence all apis available there can\nbe leveraged here - namely to throw error, call workflow, or to log real time etc.\n\n\nNote that you can write any combination of these 3 functions in your script code. At least one is\nrequired.\n\n\nTo create this script we need to use the action - Create Integration Scripts from the scripting\napplication. We need to choose the Object structure name (in this case MXPO) and the fact that\nwe are using the outbound processing. Next all you need to do is create the script code and\nsave. When you save, the script is auto-magically attached to the Object Structure processing.\n\n\n\n\n","type":"Mdx","contentDigest":"307fdc48d76f2826715d3081ccd9f95a","owner":"gatsby-plugin-mdx","counter":158},"frontmatter":{"title":"Object Structure Scripting"},"exports":{},"rawBody":"---\ntitle: Object Structure Scripting\n---\n\nThe Object Structure provides the message definition and content for other integration components like the Publish Channel. In addition, the object structure by itself can support the exchange of Maximo data with external applications/clients via REST, for example. Using a script on the object structure applies to all uses as shown in the diagram below.\n\n\n![OS use cases](osusecase.jpg)\n\n\nA script on an object structure such as MXITEM, can impact the processing of item data through REST, application Import, Enterprise Service and Invocation/Publish Channel.\n\n## Creating a Script\n\nThe 4 screen shots below identify the steps to create a new script for use with integration. This example will create a script for the MXITEM object structure that would run during the inbound processing.\n\n![OS script](osscript.jpg)\n\n![OS script name](osscriptname.jpg)\n\n![OS script code](osscriptcode.jpg)\n\n\n## Object Structure Script Processing - Inbound\n\nThe framework that supports the inbound processing of an object structure provides methods, or hooks, where custom Java code can be implemented to alter or enhance the processing of the data through the object structure to the Maximo business objects (MBOs).  With the introduction of scripting, these same functions, or hooks, are available to use by an automation script to perform similar customizations that can be done using Java.  In the case of the processing of Object Structures, a custom Java class and a custom automation script can be implemented on one object structure at the same time (Note: this does not apply to all integration components).\n\nThe inbound processing of an object structure provides a number of predefined methods, or functions, that must be extended by an automation script in order to implement custom processing via a script.  These functions support implementing logic at different points in the processing of message into Maximo.\n\n### Prior to any MBO processing\n\n|Function|\n|:--------------------------------|\n|beforeProcess(ctx)|\n\n\nThis function would be processed once for each noun in the inbound message. If the \tinbound message had 5 items, each item would be considered a noun.\n\n### During the processing of MBOSets and MBOs\n\n|Function|\n|:--------------------------------|\n|beforeCreateMboSet(ctx)|\n|afterCreateMboSet(ctx)|\n|mboRules(ctx)|\n|beforeMboData(ctx)|\n|afterMboData(ctx)|\n\n\nThese functions would be processed sequentially for each object within every noun \tin the inbound message.  If the object structure for an item contained the Item \tobject and the itemspec object, the functions above would process sequentially for \titem and then itemspec.\n\n\n### After the MBO processing\n\n|Function|\n|:--------------------------------|\n|preSaveRules(ctx)|\n|changeStatus(ctx)|\n\n\nThese functions would be processed once for each noun in the inbound message.\n\n\nThere is a context (ctx) that is passed between the processing of the object structure and the script in order for the script to implement custom code. This context is supported bi-directionally. There are pre-defined APIs available on the context:\n\n### Context (ctx) Apis\nThe matrix below outlines the apis (column on left) and their most common uses within the available functions (row across the top).\n\n\n![OS script](osinmatrix.jpg)  \n\n\nThe `ctx` variable is explained below. Note that some cases are applicable to both inbound and outbound and some of them are specific to either inbound or outbound.\n\n\n\n|Context Function|Description|Applicability|\n|:-----------|:-----------------------------------------------------------------|:-------------------|\n|ctx.getMosDetailInfo()|this provides the integration data dictionary cache information for the object in the the object structure being processed.|Inbound and outbound|\n|ctx.skipMbo()|this supports the skipping of a MBO (i.e. don’t process) on the inbound/outbound message|Inbound and outbound|\n|ctx.skipTxn()|this supports the skipping an entire transaction (i.e. message) from processing|Inbound and outbound|\n|ctx.complete()|this supports ending the processing at the point of execution – will not process the children data of the message|Inbound and outbound|\n|ctx.process()|this supports continuing the processing at the point of execution – likely used as part of conditional logic|Inbound and outbound|\n|ctx.getParentMbo()|retrieves the parent mbo – can be used from a child that does not yet have a mbo created.|Inbound|\n|ctx.isPrimary()|identifies if the current mbo is the root level mbo of the object structure|Inbound|\n|ctx.getUserInfo()|supports the retrieval of the user info.This would be needed for a script to create a new mbo|Inbound and outbound|\n|ctx.bypassMbo()|supports by-passing the mbo creation and continuing to the next mbo to be processed. This could be used when there is a case where one mbo creates a child mbo, so the integration processing wants to bypass the creation of that child mbo|Inbound|\n|ctx.getMsgType()|provides access to the message type (Sync, Create etc).|Inbound|\n|ctx.setMsgType(String msgType)|provides support to set the message type (Sync, Create etc). Can be used before processing only|Inbound|\n|ctx.getData()|provides access to StructureData (XML message)|Inbound|\n|ctx.getMboSet()|Gets the mboset in context for the level that is getting processed now|Inbound|\n|ctx.setMboSet()|sets the mboset for the current level. This is leveraged for cases where one would want to create the mboset for that level in a custom way.|Inbound|\n|ctx.setMbo(MboRemote mbo)|this sets the mbo for the level. This is done when we want to create or find the mbo in a custom way.|Inbound|\n|ctx.getPrimaryMboSet()|this gets the primary mboset (the root object) for this object structure.|Inbound|\n|ctx.getPrimaryMbo()|provides support for retrieving the primary (root) mbos of an object structure when processing a child mbo.|Inbound|\n|ctx.setProcessTable(String processTable)|used for setting the table for a process – for example, when you have a non-persistent mbo such as MXRECEIPT, it has processing logic to determine the table(mbo) to be updated (either MATRECTRANS or SERVRECTRANS). This api should be used in the beforeProcess(ctx) function.|Inbound|\n|ctx.setSkipBaseAdditionalRules()|used in the preSaveRules(ctx) function, this can be used to inject custom logic to operate on a completed object structure that is now prepared at this point in the processing.|Inbound|\n|ctx.processAsUpdate()|Sets the processing action of a MBO to be an Update (versus an Add or Delete).|Inbound|\n|ctx.processAsAdd()|Sets the processing action of a MBO to be an Add (versus an Update or Delete).|Inbound|\n|ctx.processAsAtEnd()|Sets the processing action of a MBO to be an Add (versus an Update or Delete) and will create the MBO at the end of the collection rather than by default it would be created at the top of the MBO collection..|Inbound|\n\n\n### Inbound Script Examples using the Functions and APIs mentioned above\n\nMany of the examples below were done by enabling Application Import and Export in the Item Master application using the MXITEM object structure. \nAn item was exported and the XML was modified to a smaller set of attributes as shown below. This XML was first imported with no script to ensure it would successfully create an Item. \nOn subsequent tests, the Item Number was changed to ensure that a new record could be created (avoid duplicate errors).\n\n```xml\n?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SyncMXITEM xmlns=\"http://www.ibm.com/maximo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" creationDateTime=\"2014-10-03T15:36:12-04:00\" transLanguage=\"EN\" baseLanguage=\"EN\" messageID=\"1412364918445435277\" maximoVersion=\"7 6 20140925-2230 V7600-211\">\n  <MXITEMSet>\n    <ITEM>\n      <DESCRIPTION>Centrifugal Pump 100-1 GPM, 60 FT-HD</DESCRIPTION>\n      <HIERARCHYPATH>PUMP \\ CNTRFGL</HIERARCHYPATH>\n      <ITEMNUM>PUMP100-1</ITEMNUM>\n      <ITEMSETID>SET1</ITEMSETID>\n      <ITEMTYPE>ITEM</ITEMTYPE>\n      <LOTTYPE>NOLOT</LOTTYPE>\n      <STATUS>ACTIVE</STATUS>\n    </ITEM>\n  </MXITEMSet>\n\t</SyncMXITEM>\n\n```\n\n\n**Function: beforeProcess(ctx)** \n\n\nThis function will process prior to any MBOs being retrieved or created by the object structure processing.\nIf you are using the object structure (OS) with application import, REST/OSLC api or calling the OS using SOAP or XML over HTTP, \nthe inbound processing class is the only placeholder to inject custom code \n(if you were using an Enterprise Service you would have additional processing points for custom code).   \n\n\nIf external applications are calling the object structure but that application cannot do any filtering of messages, \nyou could implement filtering in the function using the ctx.skipTxn() api. \nImplementing filtering here is a good choice since there has been no extensive processing of the data at this point. \nA skipped transaction would avoid unnecessary processing.\nThis script will filter out any items where the LOTTYPE = NOLOT.\n\n```javascript\nfunction beforeProcess(ctx)\n{\n  var lot=ctx.getData().getCurrentData(\"LOTTYPE\")  \n  if (lot==\"NOLOT\")\n  {\n    ctx.skipTxn();\n  }\n}\n```\n\nIn the above script, the ctx.getData().getCurrentData uses the structureData api to retrieve the Lot Type value from XML message and sets it to the 'lot' variable.  \nThen a condition tests the value of the variable and calls the ctx.skipTxn() api for the framework to skip the processing of the message.  \nNote that the response of processing is still 'success' (the same as if the record was created in Maximo) since no exception was raised.  \nWhen testing a scenario like this, one way to verify the behavior of your script is to load the record with the script as active and then load again when the script is configured as not active. \nIn the test above, with the script active, there was no item added.  With the script not active, a new item was created.\n\n\n**Function: mboRules(ctx)**\n\n\nThe mboRules(ctx) function [tied to the checkBusinessRules() method of the object structure processing class]  operates prior the creation of each mbo. This can be used to skip processing of a specific mbo, transaction or continue processing.  A mbo can also be created at this point as well.\n\nThe example below is for the MXINVISSUE object structure that accepts Issue transactions of type Issue and Return but does not support type Invoice.  This script will filter out the types that are  Invoice.\n\n```javascript\nfunction mboRules(ctx)\n{\n\n  if (ctx.getMosDetailInfo().getObjectName() == \"MATUSETRANS\")\n  { \n    var type=ctx.getData().getCurrentData(\"ISSUETYPE\")\n    if (type NOT IN (\"ISSUE\",\"RETURN\"))\n    {\n      ctx.skipMbo(); \n    }\n  } \n} \n```\n\n\n**Functions:  beforeMboData(ctx) and afterMboData(ctx) **\n\nThe beforeMBOData function [tied to the presetMboRulesSet() method of the object structure processing class] is available as the MBO is being created but before MIF processing sets values to the MBO.\nThe afterMboData(ctx) [tied to the setAdditionalData() method of the object structure processing class]  is available after the MBO is created and the values are set \nto the MBO by the MIF.  The MBO data is pre-save and processing could be implemented to create additional related MBOs that would be included in the transaction or \nchange data in MBOs using custom logic.  Since the MBO columns are set by the MIF at this point, by default script processing could not set the field values.  \nIf there is a need to set the field values at this point in the processing, then you would need to configure the field as Set Restricted in the object structure so \nthat the MIF does not set this and then provide logic to set the value in your script. \nThe primary difference between the 'before' and 'after' function is that the 'before' allows your code to set a field value conditionally and when that condition is\n not met the MIF will set the field using the value in the incoming message.  The 'after' function approach will use the value your code implements and the MIF \n will not set the field (since the field will need to be Set Restricted).\n\n**beforeMboData(ctx)** Example\nBelow is an example XML message and script using the 'before' function.  The XML is a simple MXITEM xml to create a new Item in Maximo\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SyncMXITEM xmlns=\"http://www.ibm.com/maximo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <MXITEMSet>\n    <ITEM>\n      <DESCRIPTION>New Item</DESCRIPTION>\n      <HIERARCHYPATH>PUMP \\ CNTRFGL</HIERARCHYPATH>\n      <ITEMNUM>NEWITEM01</ITEMNUM>\n      <COMMODITYGROUP>MOTOR</COMMODITYGROUP>\n      <ITEMSETID>SET1</ITEMSETID>\n    </ITEM>\n  </MXITEMSet>\n</SyncMXIT\n```\n\n\nThe script below, \n1. determines that the MBO being processed is ITEM\n2. set the HIERARCHYPATH field from the message to a variable (hier).\n3. evaluates the value of the variable hier to be equal to 'PUMP \\ CNTRFLG'  \n   * if equal, it defaults the value PUMP to the Commodity Group field in the MBO. The value is set with DELAYVALIDATION so that any processing that occurs after this script executes cannot set this field value. \n   * if not equal,  the script does not set the value and the value will be set to MOTOR from the incoming message by the MIF.\n\n\n```javascript\nfunction beforeMboData(ctx)\n{\n  if (ctx.getMosDetailInfo().getObjectName() == \"ITEM\")\n  { \n    var hier=ctx.getData().getCurrentData(\"HIERARCHYPATH\")\n    if (hier == \"PUMP \\\\ CNTRFGL\")\n    {\n      var mbo = ctx.getMbo(); \n      var MboConstants = Java.type(\"psdi.mbo.MboConstants\");\n      mbo.setValue(\"commoditygroup\",\"PUMP\",MboConstants.DELAYVALIDATION);\n    }\n  } \n}\n```\n\n\n**afterMboData(ctx)** Example\nBelow is an example XML message and script using the 'after' function.  The XML is a simple MXITEM xml to create a new Item in Maximo\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<SyncMXITEM xmlns=\"http://www.ibm.com/maximo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <MXITEMSet>\n    <ITEM>\n      <DESCRIPTION>New Item</DESCRIPTION>\n      <HIERARCHYPATH>PUMP \\ CNTRFGL</HIERARCHYPATH>\n      <ITEMNUM>NEWITEM01</ITEMNUM>\n      <COMMODITYGROUP>MOTOR</COMMODITYGROUP>\n      <ITEMSETID>SET1</ITEMSETID>\n    </ITEM>\n  </MXITEMSet>\n</SyncMXIT>\n```\n\n\nThe script logic below is identical to the logic used in the 'before' example above.  An additional configuration was that the Commodity Code was configured as \nSet Restricted to prevent the MIF from setting the field value.  This is needed since the MIF default processing will always set fields with 'DELAYVALIDATION'\n which prevent any subsequent processing from overriding the value set by the MIF. \n\nThe script:\n1. determines that the MBO being processed is ITEM\n2. set the HIERARCHYPATH field from the message to a variable (hier).\n3. evaluates the value of the variable hier to be equal to 'PUMP \\ CNTRFLG'  \n   * if equal, it defaults the value PUMP to the Commodity Group field in the MBO. The value is set with DELAYVALIDATION so that the any processing that occurs after this script executes cannot set this field value. \n   * if not equal,  the script does not set the value and the field will not be set when saved unless the MBO provides a default value.\n\n\n```javascript\nfunction afterMboData(ctx)\n{\n\n  if (ctx.getMosDetailInfo().getObjectName() == \"ITEM\")\n  { \n    var hier=ctx.getData().getCurrentData(\"HIERARCHYPATH\")\n    if (hier == \"PUMP \\\\ CNTRFGL\")\n    {\n      var mbo = ctx.getMbo(); \n      \n      mbo.setValue(\"commoditygroup\",\"PUMP\",MboConstants.DELAYVALIDATION);\n    }\n  } \n}\n```\n\n\nIf you need to use the afterMboData function and cannot Set Restrict the field in the object structure, there is an option to 'reset' the mbo field flag that will allow you to change the field value after it has been set by either the MIF or the MBO.  \nThe script code snippet would look like this:\n\n\n```javascript\n.\n.\nmbo.setFieldFlag(\"commoditycode\", MboConstants.NOSETVALUE, false);\nmbo.setValue(\"commoditygroup\",\"PUMP\",MboConstants.DELAYVALIDATION);\n.\n.\n```\n\n\n**Functions:  changeStatus(ctx)**\n\nThe changeStatus(ctx) function [tied to the changeStatus () method] is available to provide additional capability beyond what is provided by the MIF's \nbase class for change status (statefulMicSetIn).  Using this function requires that the processing class of the object structure has either statefulMicSetIn or a \nclass that extends statefulMicSetIn to be registered. \n\n\nExamples of where this function might be used is when \n1.\t1.the processing needs to support more than the 3 default parameters (status, memo, date) of change status.\n2.\t2.the processing needs to set the status date field rather than using the default system datetime.  Note: the MBO business logic may prevent using dates that are in the future or past, or some MBOs do not support accepting the date for a changestatus (always uses the system datetime).  The following sample was used with the MXPO object structure since the status date of the PO can be set to something other than the system date.\n\n\nThe following Java Script example will set the Memo field related to the Change Status to a string value when there is no memo value (NP_STATUSMEMO) passed in the inbound integration message.  Additionally it will set the date field to the date passed in the STATUSDATE element of the inbound message (rather than the MBO using the default system datetime).\n\n\n```javascript\nimportPackage(Packages.psdi.server);\nimportPackage(Packages.psdi.mbo);\n\nfunction changeStatus(ctx)\n{\n     var mbo = ctx.getMbo();\n     var struc = ctx.getData();\n     var stat = struc.getCurrentData(\"STATUS\");\n     var statdate = struc.getCurrentDataAsDate(\"STATUSDATE\");\n     var memo = struc.getCurrentData(\"NP_STATUSMEMO\");\n     if(struc.isCurrentDataNull(\"NP_STATUSMEMO\"))\n     {\n        memo = \"Status change via Integration\";\n     }\n    mbo.changeStatus(stat, statdate, memo, MboConstants.NOACCESSCHECK);\n}\n```\n\n\nWhen script executes changeStatus, this will prevent the processing class on the object structure from executing it as well (executes only once).\n\n\n## Object Structure Script Processing - Outbound\n\n\nIts often required to manipulate the XML/JSON data serialization in the Integration Object\nstructure layer. Take the case of outbound messages where the Object structure processing\nwould serialize the Mbo structure into a XML or json message. Some of the common use cases\nare listed below:\n\n* To override certain values in the xml or json based on the current mbo state.\n* Another use case maybe to skip some mbos or attributes based on certain conditions.\n\nYou may think that you can do it in exits. However exits are further down the line in outbound\nprocessing and may-not be very efficient to let the data get serialized to json/xml and then get\ndropped. The below example in py shows the 3 functions one can define to interface with the\nObject structure serialization process. The 3 methods are listd below:\n\n\n|Function|Purpose|\n|:--------------|:---------------------------------------------------------|\n|overrideValues(ctx)|Used for the purpose of overriding the mbo attribute values as they get serialized to json/xml|\n|skipMbo(ctx)|Used for the purpose of skipping the Mbos before serialization. These skipped mbos will not be part of the xml/json generated|\n|skipCols(ctx)|Used for skipping mbo attributes before serialization.|\n\nNote that all these functions take in a common parameter ie the ctx - which is an object of type\npsdi.iface.mos.OSDefnScriptContext (refer to the table where we describe all `ctx` functions for outbound). \nThis object contains the state of the serialization and helps the script code to figure out at what level (in the Object structure hierarchy) \nwe are at the point of that call back.\n\nThe code below can be applied to the MXPO object structure - outbound. \n\n\n```python\ndef overrideValues(ctx):\n  if ctx.getMboName()=='PO' and ctx.getMbo().isNull(\"description\")==True:\n    ctx.overrideCol(\"DESCRIPTION\",\"PO \"+ctx.getMbo().getString(\"ponum\"))\n\ndef skipMbo(ctx):\n  if ctx.getMboName()=='PO':\n    if ctx.getMbo().getMboSet(\"poline\").count()==0:\n      ctx.skipTxn()\n  elif ctx.getMboName()=='POLINE':\n    if ctx.getMbo().isNull(\"itemnum\"):\n      ctx.skipMbo()\n\ndef skipCols(ctx):\n  if ctx.getMboName()=='POLINE':\n    if ctx.getMbo().getBoolean(\"taxed\")!=True:\n      ctx.skipCol(['tax1','tax2','tax3','tax4','tax5'])\n```\n\nThe points to note here are:\n1. 1.In the override cols note that we are overriding the description only when the object is\nPO and the description is null. This will not change the PO mbo description. It will just\nhave the description in the json/xml.\n2. 2.In the skipMbo thing we are will skip the poline processing if line is a service line. We are\nalso going to skip the PO itself if there are no lines for it.\n3. 3.In the skipCols we check for the mbo in process to be POLINE and if taxed is set to\nfalse, we skip all the tax attributes.\n4. 4.These ctx vars all extend the “service” global var and hence all apis available there can\nbe leveraged here - namely to throw error, call workflow, or to log real time etc.\n\n\nNote that you can write any combination of these 3 functions in your script code. At least one is\nrequired.\n\n\nTo create this script we need to use the action - Create Integration Scripts from the scripting\napplication. We need to choose the Object structure name (in this case MXPO) and the fact that\nwe are using the outbound processing. Next all you need to do is create the script code and\nsave. When you save, the script is auto-magically attached to the Object Structure processing.\n\n\n\n\n","fileAbsolutePath":"/home/sls/git/maximo-app-framework/maximo-autoscript-documentation/src/pages/integration/osevents.mdx"}}},
    "staticQueryHashes": ["1364590287","137577622","2102389209","2456312558","2746626797","3018647132","3037994772","768070550"]}